{
  "name": "ArduinoProcessScheduler",
  "tagline": "An Arduino Object Oriented Service Scheduler to Replace Them All",
  "body": "# ArduinoProcessScheduler\r\nAn Arduino Object Oriented Cooperative Process Scheduler to Replace Them All\r\n\r\n## Features\r\n- Fine Grained Control Over How Often a Process Runs (Periodically, Iterations, or as Often as Possible)\r\n- Exception Handling (wait what?!)\r\n- Atomicity Support\r\n- Dynamically Add/Remove and Enable/Disable Processes\r\n- Automatic Process Monitoring Statistics (Automatically calculates % CPU time for service)\r\n- Truly object oriented (a Process is no longer just a callback function like other libraries)\r\n\r\n## Basic Usage\r\nThere are two classes to worry about: `Scheduler` and `Process`.\r\n\r\n### Class `Scheduler`:\r\nA `Scheduler` oversees and manages `Processes`. There should only be one `Scheduler` in your project. Inside of `void loop()`, the scheduler's `run()` method should be repeatedly called.\r\n\r\n### Class `Process`:\r\nA service can be thought of as job or a task that needs to be run at certain times. Each Process had be scheduled to run Periodically\r\nConstantly, or Periodically/Constantly with a set number of run iterations.\r\n\r\nEach project will have multiple services, here are some examples of `Processes`:\r\n  - A Process to handle user input\r\n  - A Process to run a basic webserver\r\n  - A Process to update a display\r\n\r\n`Process` is a base class that should be extended to handle your particular Process (such as the examples mentioned above). The scheduler's will call the following virtual function as an entry point when it is time for you service to run:\r\n```\r\n    virtual void service();\r\n```\r\nFrom here your `service()` routine is expected to be non-blocking, and return from `service()` as soon as possible (that means no long `delay()`'s). Fortunately, since your service routine is a method inside a class, you can store the state of your service in custom class attributes before returning, so you know where you left off when the scheduler calls your Process again. As soon you return from `service()`, control is transferred back to the Scheduler (it will also be transferred back if you raise an Exception--advanced).\r\n\r\nAdditionally, each Process inherits the following virtual functions which are called by the `Scheduler` at the appropriate times. Note you are guaranteed that only one of these methods will exist in the call stack at once, even if an interrupt fires trying to modify this Process at the same time (such as with `add()`, `destroy()`, `enable()`, or `disable()`). This also includes the `service()` method mentioned above. You do not have to worry about concurrency!\r\n\r\n**Thanks to the magic of virtual functions, you don't have to impliment any of these unless your particular Process needs them:**\r\n```\r\n    virtual void setup()\r\n    virtual void cleanup()\r\n\r\n    virtual void onEnable()\r\n    virtual void onDisable()\r\n\r\n    virtual void overScheduledHandler(uint32_t behind)\r\n```\r\n\r\n#### `setup()`\r\nThis method is called by the scheduler when the Process is being added to the scheduling chain with `add()`, it is guaranteed to only be called once when a Process not part of the scheduling chain is being added (`add()`). Keep in mind it will still be called if the Process is removed from the scheduling chain with `destroy()`, then added again with `add()`.\r\n\r\n#### `cleanup()`\r\nThis is only called once when a `Process` part of the scheduling chain is being removed from the scheduling chain with `destroy()`. This method should undo whatever was done in `setup()`. You are guaranteed it will not be called unless `setup()` was called previously.\r\n\r\n#### `onEnable()`\r\nThis method is called only once when a disabled task is being enabled with `enable()`.\r\n\r\n#### `onDisable()`\r\nThis method is called only once when a enabled task is being disabled with `disable()`. You are guaranteed it will not be called unless `onEnable()` was called previously. It should undo whatever `onEnable()` did.\r\n\r\n#### `overScheduledHandler(uint32_t behind)`\r\nThis method is called if the scheduler can not meet the current set period for the Process and is falling behind. The scheduler will pass in variable `behind` containing how many milliseconds (or microseconds) behind the scheduler is with this task. Inside this method might be a good time increase the period between when this task is run, then call `resetSchedulerWarning()` to clear the warning.\r\n\r\n\r\n## API\r\n### `Scheduler` Methods:\r\n\r\n\r\n\r\n#### Constructor\r\n```\r\nScheduler()\r\n```\r\nCreate a Scheduler object.\r\n\r\n**Returns:** `Scheduler`\r\n___\r\n\r\n#### run()\r\n```\r\nrun()\r\n```\r\nThis method runs one pass through the scheduler. It is the heart of the scheaduler, this method should be called repeatedly inside of `void loop()`\r\n\r\n**Returns:** `void`\r\n___\r\n\r\n\r\n#### getID()\r\n```\r\ngetID(Process &service)\r\n```\r\nGet the unique id for the service. Same as `service.getID()`.\r\n\r\n**Returns:** `uint8_t`\r\n___\r\n\r\n#### isRunningProcess()\r\n```\r\nisRunningProcess(Process &service)\r\n```\r\nDetermine if the scheduler is in the middle of running this service. Same as calling `service.isRunningProcess()`\r\n\r\n**Returns:** `bool`\r\n___\r\n\r\n#### isEnabled()\r\n```\r\nisEnabled(Process &service)\r\n```\r\nDetermines if this service is enabled. Same as calling `service.isEnabled()`\r\n\r\n**Returns:** `bool`\r\n___\r\n\r\n#### getCurrProcess()\r\n```\r\ngetCurrProcess()\r\n```\r\nGet pointer to the current service being run by the scheduler. Return NULL if no service being currently run.\r\n\r\n**Returns:** `Process*`\r\n___\r\n\r\n#### countProcesses()\r\n```\r\ncountProcesses(bool enabledOnly = true)\r\n```\r\nGet number of servies in the scheduler's chain. If enabledOnly is true, only the enabled Processes will be counted.\r\n\r\n**Returns:** `uint8_t`\r\n___\r\n\r\n#### getCurrTS()\r\n```\r\ngetCurrTS()\r\n```\r\nReturns the current internal timestamp. Either will be the same as `millis()` or `micros()`\r\n\r\n**Returns:** `uint32_t`\r\n___\r\n\r\n\r\n#### add()\r\n```\r\nadd (Process &service))\r\n```\r\nAdd the service to the scheduler, same as calling `service.add()`. Note, this will trigger the service's `setup()` method to fire. This method can only fail inside an interrupt routine, particularly when an interrupt interrupts any call to either `add()` or `remove()`. It will also fail if the service is already added.\r\n\r\n**Returns:** type `SchedulerAction`, `ACTION_NONE` on failure, `ACTION_SUCCESS` on success.\r\n___\r\n\r\n#### destroy()\r\n```\r\ndestroy (Process &service))\r\n```\r\nRemove the service from the scheduler. Same as calling `service.destroy()`. Note, this will trigger the service's `cleanup()` method to fire. If the service is not disabled, it will first call `disable()`. This method can only fail inside an interrupt routine, particularly when an interrupt interrupts any call to either `add()` or `remove()`. It will first try and QUEUE the request for later, before failing. It will also fail if the service is already destroyed.\r\n\r\n**Returns:** type `SchedulerAction`, `ACTION_NONE` on failure, `ACTION_QUEUED` on Queuing it, `ACTION_SUCCESS` on success.\r\n___\r\n\r\n#### enable()\r\n```\r\nenable (Process &service))\r\n```\r\nEnable a service, same as calling `service.enable()`. Note, this will trigger the service's `onEnable()` method to fire. This method call will always succeed if it was not called on itself from a method inside of this service. If it was, the scheduler will queue the request. Also, the request will fail if the service is already enabled or is destroyed.\r\n\r\n**Returns:** type `SchedulerAction`, `ACTION_NONE` on failure, `ACTION_QUEUED` on Queuing it, `ACTION_SUCCESS` on success.\r\n___\r\n\r\n#### disable()\r\n```\r\ndisable (Process &service))\r\n```\r\nDisable a service, same as calling `service.disable()`. Note, this will trigger the service's `onDisable()` method to fire. This method call will always succeed if it was not called on itself from a method inside of this service. If it was, the scheduler will queue the request. Also, the request will fail if the service is already enabled or is destroyed.\r\n\r\n**Returns:** type `SchedulerAction`, `ACTION_NONE` on failure, `ACTION_QUEUED` on Queuing it, `ACTION_SUCCESS` on success.\r\n___\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}